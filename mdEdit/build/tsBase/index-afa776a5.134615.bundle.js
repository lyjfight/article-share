!function(){"use strict";var s,n={2510:function(s,n){n.Z='<h1 id="typescript的基本介绍">TypeScript的基本介绍</h1>\n<h2 id="一、typescript-是什么">一、TypeScript 是什么</h2>\n<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的 提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系:</p>\n<img width="250" alt="image" style="margin: 20px auto;display: block;" src="https://user-images.githubusercontent.com/40552704/177522907-93875f39-3fa9-4cd7-be09-5e36eaa1b327.png">\n\n<table>\n<thead>\n<tr>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>\n<td>一种脚本语言，用于创建动态网⻚</td>\n</tr>\n<tr>\n<td>可以在编译期间发现并纠正错误</td>\n<td>作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td>强类型，支持静态和动态类型</td>\n<td>弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td>可以直接在浏览器中使用</td>\n</tr>\n<tr>\n<td>支持模块、泛型和接口</td>\n<td>不支持模块，泛型或接口</td>\n</tr>\n<tr>\n<td>社区的支持仍在增⻓，而且还不是很大</td>\n<td>大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h2 id="二、typescript-基础类型">二、TypeScript 基础类型</h2>\n<h3 id="21-boolean-类型">2.1 Boolean 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ES5:var isDone = false;</span>\n</code></pre>\n<h3 id="22-number-类型">2.2 Number 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// ES5:var count = 10;</span>\n</code></pre>\n<h3 id="23-string-类型">2.3 String 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;semliker&quot;</span>; <span class="hljs-comment">// ES5:var name = &#x27;semlinker&#x27;;</span>\n</code></pre>\n<h3 id="24-array-类型">2.4 Array 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// ES5:var list = [1,2,3];</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Array&lt;number&gt;泛型语法 // ES5:var list = [1,2,3];</span>\n</code></pre>\n<h3 id="26-enum-类型">2.6 Enum 类型</h3>\n<p><strong>1.数字枚举</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-variable constant_">NORTH</span>,\n  <span class="hljs-variable constant_">SOUTH</span>,\n  <span class="hljs-variable constant_">EAST</span>,\n  <span class="hljs-variable constant_">WEST</span>,\n}\n<span class="hljs-keyword">let</span> <span class="hljs-attr">dir</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">NORTH</span>;\n</code></pre>\n<p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增⻓。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。\n以上的枚举示例经编译后，对应的 ES5 代码如下</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) {\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;NORTH&quot;</span>] = <span class="hljs-number">0</span>)] = <span class="hljs-string">&quot;NORTH&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;SOUTH&quot;</span>] = <span class="hljs-number">1</span>)] = <span class="hljs-string">&quot;SOUTH&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;EAST&quot;</span>] = <span class="hljs-number">2</span>)] = <span class="hljs-string">&quot;EAST&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;WEST&quot;</span>] = <span class="hljs-number">3</span>)] = <span class="hljs-string">&quot;WEST&quot;</span>;\n})(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = {}));\n<span class="hljs-keyword">var</span> dir = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">NORTH</span>;\n</code></pre>\n<p>当然我们也可以设置 NORTH 的初始值，比如:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-variable constant_">NORTH</span> = <span class="hljs-number">3</span>,\n  <span class="hljs-variable constant_">SOUTH</span>,\n  <span class="hljs-variable constant_">EAST</span>,\n  <span class="hljs-variable constant_">WEST</span>, \n}\n</code></pre>\n<p><strong>2.字符串枚举</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-variable constant_">NORTH</span> = <span class="hljs-string">&quot;NORTH&quot;</span>,\n  <span class="hljs-variable constant_">SOUTH</span> = <span class="hljs-string">&quot;SOUTH&quot;</span>,\n  <span class="hljs-variable constant_">EAST</span> = <span class="hljs-string">&quot;EAST&quot;</span>,\n  <span class="hljs-variable constant_">WEST</span> = <span class="hljs-string">&quot;WEST&quot;</span>,\n}\n</code></pre>\n<p>以上代码对应的 ES5 代码如下:</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) {\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;NORTH&quot;</span>] = <span class="hljs-string">&quot;NORTH&quot;</span>;\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;SOUTH&quot;</span>] = <span class="hljs-string">&quot;SOUTH&quot;</span>;\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;EAST&quot;</span>] = <span class="hljs-string">&quot;EAST&quot;</span>;\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;WEST&quot;</span>] = <span class="hljs-string">&quot;WEST&quot;</span>;\n})(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = {}));\n</code></pre>\n<p><strong>3.异构枚举</strong></p>\n<p>异构枚举的成员值是数字和字符串的混合:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Enum</span> { \n  A,\n  B,\n  C = <span class="hljs-string">&quot;C&quot;</span>,\n  D = <span class="hljs-string">&quot;D&quot;</span>,\n  E = <span class="hljs-number">8</span>,\n  F,\n}\n</code></pre>\n<p>以上代码对于的 ES5 代码如下:</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Enum</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Enum</span>) {\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;A&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;A&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;B&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;B&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;C&quot;</span>] = <span class="hljs-string">&quot;C&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;D&quot;</span>] = <span class="hljs-string">&quot;D&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;E&quot;</span>] = <span class="hljs-number">8</span>] = <span class="hljs-string">&quot;E&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;F&quot;</span>] = <span class="hljs-number">9</span>] = <span class="hljs-string">&quot;F&quot;</span>;\n})(<span class="hljs-title class_">Enum</span> || (<span class="hljs-title class_">Enum</span> = {}));\n</code></pre>\n<p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”:</p>\n<pre><code class="language-ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Enum</span>.<span class="hljs-property">A</span>) <span class="hljs-comment">//输出:0 </span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Enum</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 输出:A</span>\n</code></pre>\n<h3 id="27-any-类型">2.7 Any 类型</h3>\n<p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型(也被称作全局超级类型)。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">666</span>;\nnotSure = <span class="hljs-string">&quot;semlinker&quot;</span>;\nnotSure = <span class="hljs-literal">false</span>;\n</code></pre>\n<p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由:<code>TypeScript</code> 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>;\nvalue.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span>; <span class="hljs-comment">// OK</span>\nvalue.<span class="hljs-title function_">trim</span>(); <span class="hljs-comment">// OK</span>\n<span class="hljs-title function_">value</span>(); <span class="hljs-comment">// OK</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(); <span class="hljs-comment">// OK</span>\nvalue[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// OK</span>\n</code></pre>\n<p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如 果我们使用 <code>any</code> 类型，就无法使用 <code>TypeScript</code> 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题， TypeScript 3.0 引入了 <code>unknown</code> 类型。</p>\n<h3 id="28-unknown-类型">2.8 Unknown 类型</h3>\n<p>就像所有类型都可以赋值给 <code>any</code> ，所有类型也都可以赋值给 <code>unknown</code> 。这使得 <code>unknown</code> 成为 <code>TypeScript</code> 类型系统的另一种顶级类型(另一种是 any )。下面我们来看一下 unknown 类型的使用示 例:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\nvalue = <span class="hljs-literal">true</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-string">&quot;Hello World&quot;</span>; <span class="hljs-comment">// OK</span>\nvalue = []; <span class="hljs-comment">// OK</span>\nvalue = {}; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-title class_">Math</span>.<span class="hljs-property">random</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-literal">null</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(); <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;type&quot;</span>); <span class="hljs-comment">// OK</span>\n</code></pre>\n<p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其 他类型的变量时会发生什么?</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value1</span>: <span class="hljs-built_in">unknown</span> = value; <span class="hljs-comment">// OK</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value2</span>: <span class="hljs-built_in">any</span> = value; <span class="hljs-comment">// OK</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value3</span>: <span class="hljs-built_in">boolean</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value4</span>: <span class="hljs-built_in">number</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value5</span>: <span class="hljs-built_in">string</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value6</span>: <span class="hljs-built_in">object</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value7</span>: <span class="hljs-built_in">any</span>[] = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value8</span>: <span class="hljs-title class_">Function</span> = value; <span class="hljs-comment">// Error</span>\n</code></pre>\n<p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p>\n<p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么：</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\nvalue.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span>; <span class="hljs-comment">// Error</span>\nvalue.<span class="hljs-title function_">trim</span>(); <span class="hljs-comment">// Error</span>\n<span class="hljs-title function_">value</span>(); <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(); <span class="hljs-comment">// Error</span>\nvalue[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// Error</span>\n</code></pre>\n<p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变 为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改</p>\n<h3 id="29-tuple-类型">2.9 Tuple 类型</h3>\n<p><strong>众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。</strong> 在 <code>JavaScript</code> 中是没有元组的，元组是 <code>TypeScript</code> 中特有的类型，其工作方式类似于数组。</p>\n<p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须\n提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">tupleType</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>];\ntupleType = [<span class="hljs-string">&quot;semlinker&quot;</span>, <span class="hljs-literal">true</span>];\n</code></pre>\n<p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code> ，然后我们按照正确的类型依次初始化 <code>tupleType</code> 变量。与数组一样，我们可以通过下标来 访问元组中的元素:</p>\n<pre><code class="language-ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tupleType[<span class="hljs-number">0</span>]); <span class="hljs-comment">// semlinker</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tupleType[<span class="hljs-number">1</span>]); <span class="hljs-comment">// true</span>\n</code></pre>\n<p>在元组初始化的时候，如果出现类型不匹配的话，比如:</p>\n<pre><code class="language-ts">tupleType = [<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;semlinker&quot;</span>];\n</code></pre>\n<p>此时，TypeScript 编译器会提示以下错误信息:</p>\n<pre><code class="language-ts">[<span class="hljs-number">0</span>]: <span class="hljs-title class_">Type</span> <span class="hljs-string">&#x27;true&#x27;</span> is not assignable to <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;string&#x27;</span>.\n[<span class="hljs-number">1</span>]: <span class="hljs-title class_">Type</span> <span class="hljs-string">&#x27;string&#x27;</span> is not assignable to <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;boolean&#x27;</span>.\n</code></pre>\n<p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现\n错误，比如:</p>\n<pre><code class="language-ts">tupleType = [<span class="hljs-string">&quot;semlinker&quot;</span>];\n</code></pre>\n<p>此时，TypeScript 编译器会提示以下错误信息:</p>\n<pre><code class="language-ts"><span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;1&#x27;</span> is missing <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;[string]&#x27;</span> but required <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;[string,boolean]&#x27;</span>.\n</code></pre>\n<h3 id="210-void-类型">2.10 Void 类型</h3>\n<p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，通常会⻅到其返回值类型是 void:</p>\n<pre><code class="language-ts"><span class="hljs-comment">// 声明函数返回值为void </span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);\n}\n</code></pre>\n<p>以上代码编译生成的 ES5 代码如下:</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);\n}\n</code></pre>\n<p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为在严格模式下，它的值只能为 <code>undefined</code> :</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;\n</code></pre>\n<h3 id="211-null-和-undefined-类型">2.11 Null 和 Undefined 类型</h3>\n<p>TypeScript 里， <code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code> 。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;\n</code></pre>\n<h3 id="212-object-和--类型">2.12 object 和 {} 类型</h3>\n<p><strong>1.object 类型</strong></p>\n<p>object 类型是:TypeScript 2.2 引入的新类型，它用于表示非原始类型。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectConstructor</span> {\n  <span class="hljs-title function_">create</span>(<span class="hljs-attr">o</span>: <span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">any</span>;\n  <span class="hljs-comment">// ...</span>\n}\n\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);     <span class="hljs-comment">// OK</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);      <span class="hljs-comment">// OK</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Error</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">1337</span>);      <span class="hljs-comment">// Error</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">true</span>);      <span class="hljs-comment">// Error</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&quot;oops&quot;</span>);    <span class="hljs-comment">// Error</span>\n</code></pre>\n<p><strong>2.{} 类型</strong></p>\n<p>{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。</p>\n<pre><code class="language-ts"><span class="hljs-comment">// Type {}</span>\n<span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-comment">// Error: Property &#x27;prop&#x27; does not exist on type &#x27;{}&#x27;.</span>\nobj.<span class="hljs-property">prop</span> = <span class="hljs-string">&quot;semlinker&quot;</span>;\n</code></pre>\n<p>但是，你仍然可以使用在 <code>Object</code> 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用:</p>\n<pre><code class="language-ts"><span class="hljs-comment">// Type {}</span>\n<span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-comment">// &quot;[object Object]&quot;</span>\nobj.<span class="hljs-title function_">toString</span>();\n</code></pre>\n<h3 id="213-never-类型">2.13 Never 类型</h3>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>\n<pre><code class="language-ts"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点 </span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);\n}\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}\n}\n</code></pre>\n<h2 id="三、typescript-断言">三、TypeScript 断言</h2>\n<h3 id="31-类型断言">3.1 类型断言</h3>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。类型断言好比其他语言里的 类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>\n<p>类型断言有两种形式:</p>\n<p><strong>1.“尖括号” 语法</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;\n</code></pre>\n<p><strong>2.as 语法</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;\n</code></pre>\n<h3 id="32-非空断言">3.2 非空断言</h3>\n<p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非\n<code>null</code> 和非 <code>undefined</code> 类型。<strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p>\n<p>那么非空断言操作符到底有什么用呢?下面我们先来看一下非空断言操作符的一些使用场景。</p>\n<p><strong>1.忽略 undefined 和 null 类型</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">maybeString: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span></span>) {\n  <span class="hljs-comment">// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span>\n  <span class="hljs-comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;.</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">onlyString</span>: <span class="hljs-built_in">string</span> = maybeString; <span class="hljs-comment">// Error</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">ignoreUndefinedAndNull</span>: <span class="hljs-built_in">string</span> = maybeString!; <span class="hljs-comment">// Ok</span>\n}\n</code></pre>\n<p><strong>2.调用函数时忽略 undefined 类型</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumGenerator</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">numGenerator: NumGenerator | <span class="hljs-literal">undefined</span></span>) {\n  <span class="hljs-comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span>\n  <span class="hljs-comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span>\n  <span class="hljs-keyword">const</span> num1 = <span class="hljs-title function_">numGenerator</span>(); <span class="hljs-comment">// Error</span>\n  <span class="hljs-keyword">const</span> num2 = numGenerator!(); <span class="hljs-comment">//OK</span>\n}\n</code></pre>\n<h3 id="33-确定赋值断言">3.3 确定赋值断言</h3>\n<p>在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而\n告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n<span class="hljs-title function_">initialize</span>();\n<span class="hljs-comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) {\n  x = <span class="hljs-number">10</span>;\n}\n</code></pre>\n<p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> x!: <span class="hljs-built_in">number</span>;\n<span class="hljs-title function_">initialize</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Ok</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) {\n  x = <span class="hljs-number">10</span>;\n}\n</code></pre>\n<p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p>\n<h2 id="四、类型守卫">四、类型守卫</h2>\n<p><strong>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</strong> </p>\n<p>目前主要有四种的方式来实现类型保护:</p>\n<h3 id="41-in-关键字">4.1 in 关键字</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Admin</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">privileges</span>: <span class="hljs-built_in">string</span>[];\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Employee</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">startDate</span>: <span class="hljs-title class_">Date</span>;\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnknownEmployee</span> = <span class="hljs-title class_">Employee</span> | <span class="hljs-title class_">Admin</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">printEmployeeInformation</span>(<span class="hljs-params">emp: UnknownEmployee</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Name: &quot;</span> + emp.<span class="hljs-property">name</span>);\n  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;privileges&quot;</span> <span class="hljs-keyword">in</span> emp) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Privileges: &quot;</span> + emp.<span class="hljs-property">privileges</span>);\n  }\n  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;startDate&quot;</span> <span class="hljs-keyword">in</span> emp) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Start Date: &quot;</span> + emp.<span class="hljs-property">startDate</span>);\n  } \n}\n</code></pre>\n<h3 id="42-typeof-关键字">4.2 typeof 关键字</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">&quot;number&quot;</span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>(padding + <span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>) + value;\n  }\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">&quot;string&quot;</span>) {\n      <span class="hljs-keyword">return</span> padding + value;\n  }\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected string or number, got &#x27;</span> + padding + <span class="hljs-string">&#x27;.&#x27;</span>);\n}\n</code></pre>\n<h3 id="43-instanceof-关键字">4.3 instanceof 关键字</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Padder</span> {\n  <span class="hljs-title function_">getPaddingString</span>(): <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpaceRepeatingPadder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Padder</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> numSpaces: <span class="hljs-built_in">number</span></span>) {}\n  <span class="hljs-title function_">getPaddingString</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">numSpaces</span> + <span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringPadder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Padder</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> value: <span class="hljs-built_in">string</span></span>) {}\n  <span class="hljs-title function_">getPaddingString</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;\n  }\n}\n<span class="hljs-keyword">let</span> <span class="hljs-attr">padder</span>: <span class="hljs-title class_">Padder</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpaceRepeatingPadder</span>(<span class="hljs-number">6</span>);\n<span class="hljs-keyword">if</span> (padder <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SpaceRepeatingPadder</span>) { <span class="hljs-comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span>\n}\n</code></pre>\n<h2 id="五、联合类型和类型别名">五、联合类型和类型别名</h2>\n<h3 id="51-联合类型">5.1 联合类型</h3>\n<p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params">name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt; {\n  <span class="hljs-comment">/* ... */</span>\n};\n</code></pre>\n<p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p>\n<pre><code class="language-ts"><span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&quot;semlinker&quot;</span>);\n<span class="hljs-title function_">sayHello</span>(<span class="hljs-literal">undefined</span>);\n</code></pre>\n<h3 id="52-类型别名">5.2 类型别名</h3>\n<p>类型别名用来给一个类型起个新名字。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[];\n<span class="hljs-keyword">let</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">message: Message</span>) =&gt; {\n  <span class="hljs-comment">// ...</span>\n};\n</code></pre>\n<h2 id="六、交叉类型">六、交叉类型</h2>\n<p>在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 &amp; 运算符可以将现有的多种类型叠加到 一起成为一种类型，它包含了所需的所有类型的特性。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">let</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = {\n  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> \n}\n</code></pre>\n<h2 id="七、typescript-函数">七、TypeScript 函数</h2>\n<h3 id="71-函数类型">7.1 函数类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-title class_">IdGenerator</span>: <span class="hljs-function">(<span class="hljs-params">chars: <span class="hljs-built_in">string</span>, nums: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserId</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, id: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> name + id;\n}\n<span class="hljs-title class_">IdGenerator</span> = createUserId;\n</code></pre>\n<h3 id="72-可选参数及默认参数">7.2 可选参数及默认参数</h3>\n<pre><code class="language-ts"><span class="hljs-comment">// 可选参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserId</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, id: <span class="hljs-built_in">number</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> name + id;\n}\n<span class="hljs-comment">// 默认参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserId</span>(<span class="hljs-params">name = <span class="hljs-string">&quot;semlinker&quot;</span>, id: <span class="hljs-built_in">number</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> name + id;\n}\n</code></pre>\n<p>在声明函数时，可以通过 ? 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要 注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p>\n<h2 id="八、typescript-接口">八、TypeScript 接口</h2>\n<p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对 「对象的形状(Shape)」进行描述。</p>\n<h3 id="81-对象的形状">8.1 对象的形状</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">let</span> <span class="hljs-attr">semlinker</span>: <span class="hljs-title class_">Person</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;semlinker&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">33</span>,\n};\n</code></pre>\n<h3 id="82-可选--只读属性">8.2 可选 | 只读属性</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  age?: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n<h3 id="83-任意属性">8.3 任意属性</h3>\n<p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <code>索引签名</code> 的形式来满足上述要求。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  age?: <span class="hljs-built_in">number</span>;\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;\n}\n<span class="hljs-keyword">const</span> p1 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;semlinker&quot;</span> };\n<span class="hljs-keyword">const</span> p2 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lolo&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span> };\n<span class="hljs-keyword">const</span> p3 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kakuqo&quot;</span>, <span class="hljs-attr">sex</span>: <span class="hljs-number">1</span> }\n</code></pre>\n<h3 id="84-接口与类型别名的区别">8.4 接口与类型别名的区别</h3>\n<p><strong>1.Objects/Functions</strong></p>\n<p>接口和类型别名都可以用来描述对象的形状或函数签名:</p>\n<p><strong>接口</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetPoint</span> {\n  (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n<p><strong>类型别名</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n};\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">SetPoint</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n</code></pre>\n<p><strong>2.Other Types</strong></p>\n<p>与接口类型不一样，类型别名可以用于一些其他类型，比如原始类型、联合类型和元组:</p>\n<pre><code class="language-ts"><span class="hljs-comment">// primitive</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-built_in">string</span>;\n<span class="hljs-comment">// object</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointY</span> = { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-comment">// union</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = <span class="hljs-title class_">PartialPointX</span> | <span class="hljs-title class_">PartialPointY</span>;\n<span class="hljs-comment">// tuple</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Data</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];\n</code></pre>\n<p><strong>3.Extend</strong></p>\n<p>接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类\n型别名，而反过来是不行的。</p>\n<p><strong>Interface extends interface</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PartialPointX</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PartialPointX</span> {\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; \n}\n</code></pre>\n<p><strong>Type alias extends type alias</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n</code></pre>\n<p><strong>Interface extends type alias</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PartialPointX</span> { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; }\n</code></pre>\n<p><strong>Type alias extends interface</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PartialPointX</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n</code></pre>\n<p><strong>4.Implements</strong></p>\n<p>类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n \n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Point</span> {\n  x = <span class="hljs-number">1</span>;\n  y = <span class="hljs-number">2</span>; \n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point2</span> = {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n};\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePoint2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Point2</span> {\n  x = <span class="hljs-number">1</span>;\n  y = <span class="hljs-number">2</span>; \n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; } | { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-comment">// A class can only implement an object type or</span>\n<span class="hljs-comment">// intersection of object types with statically known members.</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PartialPoint</span> { <span class="hljs-comment">// Error</span>\n  x = <span class="hljs-number">1</span>;\n  y = <span class="hljs-number">2</span>; \n}\n</code></pre>\n<p><strong>5.Declaration merging</strong></p>\n<p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };\n</code></pre>\n<h2 id="九、typescript-类">九、TypeScript 类</h2>\n<h2 id="十、typescript-泛型">十、TypeScript 泛型</h2>\n<h2 id="十一、typescript-装饰器">十一、TypeScript 装饰器</h2>\n'}},a={};function l(s){var p=a[s];if(void 0!==p)return p.exports;var t=a[s]={exports:{}};return n[s](t,t.exports,l),t.exports}l.m=n,s=[],l.O=function(n,a,p,t){if(!a){var e=1/0;for(o=0;o<s.length;o++){a=s[o][0],p=s[o][1],t=s[o][2];for(var c=!0,r=0;r<a.length;r++)(!1&t||e>=t)&&Object.keys(l.O).every((function(s){return l.O[s](a[r])}))?a.splice(r--,1):(c=!1,t<e&&(e=t));if(c){s.splice(o--,1);var i=p();void 0!==i&&(n=i)}}return n}t=t||0;for(var o=s.length;o>0&&s[o-1][2]>t;o--)s[o]=s[o-1];s[o]=[a,p,t]},l.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(s){if("object"==typeof window)return window}}(),l.o=function(s,n){return Object.prototype.hasOwnProperty.call(s,n)},function(){var s={831:0};l.O.j=function(n){return 0===s[n]};var n=function(n,a){var p,t,e=a[0],c=a[1],r=a[2],i=0;if(e.some((function(n){return 0!==s[n]}))){for(p in c)l.o(c,p)&&(l.m[p]=c[p]);if(r)var o=r(l)}for(n&&n(a);i<e.length;i++)t=e[i],l.o(s,t)&&s[t]&&s[t][0](),s[t]=0;return l.O(o)},a=self.webpackChunkmd_edit=self.webpackChunkmd_edit||[];a.forEach(n.bind(null,0)),a.push=n.bind(null,a.push.bind(a))}();var p=l.O(void 0,[60,477,256,456],(function(){return l(357)}));p=l.O(p)}();