!function(){"use strict";var s,a={2510:function(s,a){a.Z='<h1 id="typescript的基本介绍">TypeScript的基本介绍</h1>\n<h2 id="一、typescript-是什么">一、TypeScript 是什么</h2>\n<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的 提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系:</p>\n<img width="250" alt="image" style="margin: 20px auto;display: block;" src="https://user-images.githubusercontent.com/40552704/177522907-93875f39-3fa9-4cd7-be09-5e36eaa1b327.png">\n\n<table>\n<thead>\n<tr>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>\n<td>一种脚本语言，用于创建动态网⻚</td>\n</tr>\n<tr>\n<td>可以在编译期间发现并纠正错误</td>\n<td>作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td>强类型，支持静态和动态类型</td>\n<td>弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td>可以直接在浏览器中使用</td>\n</tr>\n<tr>\n<td>支持模块、泛型和接口</td>\n<td>不支持模块，泛型或接口</td>\n</tr>\n<tr>\n<td>社区的支持仍在增⻓，而且还不是很大</td>\n<td>大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h2 id="二、typescript-基础类型">二、TypeScript 基础类型</h2>\n<h3 id="21-boolean-类型">2.1 Boolean 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ES5:var isDone = false;</span>\n</code></pre>\n<h3 id="22-number-类型">2.2 Number 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// ES5:var count = 10;</span>\n</code></pre>\n<h3 id="23-string-类型">2.3 String 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;semliker&quot;</span>; <span class="hljs-comment">// ES5:var name = &#x27;semlinker&#x27;;</span>\n</code></pre>\n<h3 id="24-array-类型">2.4 Array 类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// ES5:var list = [1,2,3];</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Array&lt;number&gt;泛型语法 // ES5:var list = [1,2,3];</span>\n</code></pre>\n<h3 id="26-enum-类型">2.6 Enum 类型</h3>\n<p><strong>1.数字枚举</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-variable constant_">NORTH</span>,\n  <span class="hljs-variable constant_">SOUTH</span>,\n  <span class="hljs-variable constant_">EAST</span>,\n  <span class="hljs-variable constant_">WEST</span>,\n}\n<span class="hljs-keyword">let</span> <span class="hljs-attr">dir</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">NORTH</span>;\n</code></pre>\n<p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增⻓。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。\n以上的枚举示例经编译后，对应的 ES5 代码如下</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) {\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;NORTH&quot;</span>] = <span class="hljs-number">0</span>)] = <span class="hljs-string">&quot;NORTH&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;SOUTH&quot;</span>] = <span class="hljs-number">1</span>)] = <span class="hljs-string">&quot;SOUTH&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;EAST&quot;</span>] = <span class="hljs-number">2</span>)] = <span class="hljs-string">&quot;EAST&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;WEST&quot;</span>] = <span class="hljs-number">3</span>)] = <span class="hljs-string">&quot;WEST&quot;</span>;\n})(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = {}));\n<span class="hljs-keyword">var</span> dir = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">NORTH</span>;\n</code></pre>\n<p>当然我们也可以设置 NORTH 的初始值，比如:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-variable constant_">NORTH</span> = <span class="hljs-number">3</span>,\n  <span class="hljs-variable constant_">SOUTH</span>,\n  <span class="hljs-variable constant_">EAST</span>,\n  <span class="hljs-variable constant_">WEST</span>, \n}\n</code></pre>\n<p><strong>2.字符串枚举</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-variable constant_">NORTH</span> = <span class="hljs-string">&quot;NORTH&quot;</span>,\n  <span class="hljs-variable constant_">SOUTH</span> = <span class="hljs-string">&quot;SOUTH&quot;</span>,\n  <span class="hljs-variable constant_">EAST</span> = <span class="hljs-string">&quot;EAST&quot;</span>,\n  <span class="hljs-variable constant_">WEST</span> = <span class="hljs-string">&quot;WEST&quot;</span>,\n}\n</code></pre>\n<p>以上代码对应的 ES5 代码如下:</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) {\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;NORTH&quot;</span>] = <span class="hljs-string">&quot;NORTH&quot;</span>;\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;SOUTH&quot;</span>] = <span class="hljs-string">&quot;SOUTH&quot;</span>;\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;EAST&quot;</span>] = <span class="hljs-string">&quot;EAST&quot;</span>;\n    <span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;WEST&quot;</span>] = <span class="hljs-string">&quot;WEST&quot;</span>;\n})(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = {}));\n</code></pre>\n<p><strong>3.异构枚举</strong></p>\n<p>异构枚举的成员值是数字和字符串的混合:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Enum</span> { \n  A,\n  B,\n  C = <span class="hljs-string">&quot;C&quot;</span>,\n  D = <span class="hljs-string">&quot;D&quot;</span>,\n  E = <span class="hljs-number">8</span>,\n  F,\n}\n</code></pre>\n<p>以上代码对于的 ES5 代码如下:</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Enum</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Enum</span>) {\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;A&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;A&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;B&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;B&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;C&quot;</span>] = <span class="hljs-string">&quot;C&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;D&quot;</span>] = <span class="hljs-string">&quot;D&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;E&quot;</span>] = <span class="hljs-number">8</span>] = <span class="hljs-string">&quot;E&quot;</span>;\n    <span class="hljs-title class_">Enum</span>[<span class="hljs-title class_">Enum</span>[<span class="hljs-string">&quot;F&quot;</span>] = <span class="hljs-number">9</span>] = <span class="hljs-string">&quot;F&quot;</span>;\n})(<span class="hljs-title class_">Enum</span> || (<span class="hljs-title class_">Enum</span> = {}));\n</code></pre>\n<p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”:</p>\n<pre><code class="language-ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Enum</span>.<span class="hljs-property">A</span>) <span class="hljs-comment">//输出:0 </span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Enum</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 输出:A</span>\n</code></pre>\n<h3 id="27-any-类型">2.7 Any 类型</h3>\n<p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型(也被称作全局超级类型)。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">666</span>;\nnotSure = <span class="hljs-string">&quot;semlinker&quot;</span>;\nnotSure = <span class="hljs-literal">false</span>;\n</code></pre>\n<p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由:<code>TypeScript</code> 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>;\nvalue.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span>; <span class="hljs-comment">// OK</span>\nvalue.<span class="hljs-title function_">trim</span>(); <span class="hljs-comment">// OK</span>\n<span class="hljs-title function_">value</span>(); <span class="hljs-comment">// OK</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(); <span class="hljs-comment">// OK</span>\nvalue[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// OK</span>\n</code></pre>\n<p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如 果我们使用 <code>any</code> 类型，就无法使用 <code>TypeScript</code> 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题， TypeScript 3.0 引入了 <code>unknown</code> 类型。</p>\n<h3 id="28-unknown-类型">2.8 Unknown 类型</h3>\n<p>就像所有类型都可以赋值给 <code>any</code> ，所有类型也都可以赋值给 <code>unknown</code> 。这使得 <code>unknown</code> 成为 <code>TypeScript</code> 类型系统的另一种顶级类型(另一种是 any )。下面我们来看一下 unknown 类型的使用示 例:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\nvalue = <span class="hljs-literal">true</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-string">&quot;Hello World&quot;</span>; <span class="hljs-comment">// OK</span>\nvalue = []; <span class="hljs-comment">// OK</span>\nvalue = {}; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-title class_">Math</span>.<span class="hljs-property">random</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-literal">null</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(); <span class="hljs-comment">// OK</span>\nvalue = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;type&quot;</span>); <span class="hljs-comment">// OK</span>\n</code></pre>\n<p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其 他类型的变量时会发生什么?</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value1</span>: <span class="hljs-built_in">unknown</span> = value; <span class="hljs-comment">// OK</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value2</span>: <span class="hljs-built_in">any</span> = value; <span class="hljs-comment">// OK</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value3</span>: <span class="hljs-built_in">boolean</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value4</span>: <span class="hljs-built_in">number</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value5</span>: <span class="hljs-built_in">string</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value6</span>: <span class="hljs-built_in">object</span> = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value7</span>: <span class="hljs-built_in">any</span>[] = value; <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">value8</span>: <span class="hljs-title class_">Function</span> = value; <span class="hljs-comment">// Error</span>\n</code></pre>\n<p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p>\n<p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么：</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\nvalue.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span>; <span class="hljs-comment">// Error</span>\nvalue.<span class="hljs-title function_">trim</span>(); <span class="hljs-comment">// Error</span>\n<span class="hljs-title function_">value</span>(); <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(); <span class="hljs-comment">// Error</span>\nvalue[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// Error</span>\n</code></pre>\n<p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变 为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改</p>\n<h3 id="29-tuple-类型">2.9 Tuple 类型</h3>\n<p><strong>众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。</strong> 在 <code>JavaScript</code> 中是没有元组的，元组是 <code>TypeScript</code> 中特有的类型，其工作方式类似于数组。</p>\n<p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须\n提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">tupleType</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>];\ntupleType = [<span class="hljs-string">&quot;semlinker&quot;</span>, <span class="hljs-literal">true</span>];\n</code></pre>\n<p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code> ，然后我们按照正确的类型依次初始化 <code>tupleType</code> 变量。与数组一样，我们可以通过下标来 访问元组中的元素:</p>\n<pre><code class="language-ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tupleType[<span class="hljs-number">0</span>]); <span class="hljs-comment">// semlinker</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tupleType[<span class="hljs-number">1</span>]); <span class="hljs-comment">// true</span>\n</code></pre>\n<p>在元组初始化的时候，如果出现类型不匹配的话，比如:</p>\n<pre><code class="language-ts">tupleType = [<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;semlinker&quot;</span>];\n</code></pre>\n<p>此时，TypeScript 编译器会提示以下错误信息:</p>\n<pre><code class="language-ts">[<span class="hljs-number">0</span>]: <span class="hljs-title class_">Type</span> <span class="hljs-string">&#x27;true&#x27;</span> is not assignable to <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;string&#x27;</span>.\n[<span class="hljs-number">1</span>]: <span class="hljs-title class_">Type</span> <span class="hljs-string">&#x27;string&#x27;</span> is not assignable to <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;boolean&#x27;</span>.\n</code></pre>\n<p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现\n错误，比如:</p>\n<pre><code class="language-ts">tupleType = [<span class="hljs-string">&quot;semlinker&quot;</span>];\n</code></pre>\n<p>此时，TypeScript 编译器会提示以下错误信息:</p>\n<pre><code class="language-ts"><span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;1&#x27;</span> is missing <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;[string]&#x27;</span> but required <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;[string,boolean]&#x27;</span>.\n</code></pre>\n<h3 id="210-void-类型">2.10 Void 类型</h3>\n<p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，通常会⻅到其返回值类型是 void:</p>\n<pre><code class="language-ts"><span class="hljs-comment">// 声明函数返回值为void </span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);\n}\n</code></pre>\n<p>以上代码编译生成的 ES5 代码如下:</p>\n<pre><code class="language-ts"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);\n}\n</code></pre>\n<p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为在严格模式下，它的值只能为 <code>undefined</code> :</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;\n</code></pre>\n<h3 id="211-null-和-undefined-类型">2.11 Null 和 Undefined 类型</h3>\n<p>TypeScript 里， <code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code> 。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;\n</code></pre>\n<h3 id="212-object-和--类型">2.12 object 和 {} 类型</h3>\n<p><strong>1.object 类型</strong></p>\n<p>object 类型是:TypeScript 2.2 引入的新类型，它用于表示非原始类型。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectConstructor</span> {\n  <span class="hljs-title function_">create</span>(<span class="hljs-attr">o</span>: <span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">any</span>;\n  <span class="hljs-comment">// ...</span>\n}\n\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);     <span class="hljs-comment">// OK</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);      <span class="hljs-comment">// OK</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Error</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">1337</span>);      <span class="hljs-comment">// Error</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">true</span>);      <span class="hljs-comment">// Error</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&quot;oops&quot;</span>);    <span class="hljs-comment">// Error</span>\n</code></pre>\n<p><strong>2.{} 类型</strong></p>\n<p>{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。</p>\n<pre><code class="language-ts"><span class="hljs-comment">// Type {}</span>\n<span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-comment">// Error: Property &#x27;prop&#x27; does not exist on type &#x27;{}&#x27;.</span>\nobj.<span class="hljs-property">prop</span> = <span class="hljs-string">&quot;semlinker&quot;</span>;\n</code></pre>\n<p>但是，你仍然可以使用在 <code>Object</code> 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用:</p>\n<pre><code class="language-ts"><span class="hljs-comment">// Type {}</span>\n<span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-comment">// &quot;[object Object]&quot;</span>\nobj.<span class="hljs-title function_">toString</span>();\n</code></pre>\n<h3 id="213-never-类型">2.13 Never 类型</h3>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>\n<pre><code class="language-ts"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点 </span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);\n}\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}\n}\n</code></pre>\n<h2 id="三、typescript-断言">三、TypeScript 断言</h2>\n<h3 id="31-类型断言">3.1 类型断言</h3>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。类型断言好比其他语言里的 类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>\n<p>类型断言有两种形式:</p>\n<p><strong>1.“尖括号” 语法</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;\n</code></pre>\n<p><strong>2.as 语法</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;\n</code></pre>\n<h3 id="32-非空断言">3.2 非空断言</h3>\n<p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非\n<code>null</code> 和非 <code>undefined</code> 类型。<strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p>\n<p>那么非空断言操作符到底有什么用呢?下面我们先来看一下非空断言操作符的一些使用场景。</p>\n<p><strong>1.忽略 undefined 和 null 类型</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">maybeString: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span></span>) {\n  <span class="hljs-comment">// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span>\n  <span class="hljs-comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;.</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">onlyString</span>: <span class="hljs-built_in">string</span> = maybeString; <span class="hljs-comment">// Error</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">ignoreUndefinedAndNull</span>: <span class="hljs-built_in">string</span> = maybeString!; <span class="hljs-comment">// Ok</span>\n}\n</code></pre>\n<p><strong>2.调用函数时忽略 undefined 类型</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumGenerator</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">numGenerator: NumGenerator | <span class="hljs-literal">undefined</span></span>) {\n  <span class="hljs-comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span>\n  <span class="hljs-comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span>\n  <span class="hljs-keyword">const</span> num1 = <span class="hljs-title function_">numGenerator</span>(); <span class="hljs-comment">// Error</span>\n  <span class="hljs-keyword">const</span> num2 = numGenerator!(); <span class="hljs-comment">//OK</span>\n}\n</code></pre>\n<h3 id="33-确定赋值断言">3.3 确定赋值断言</h3>\n<p>在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而\n告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n<span class="hljs-title function_">initialize</span>();\n<span class="hljs-comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Error</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) {\n  x = <span class="hljs-number">10</span>;\n}\n</code></pre>\n<p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> x!: <span class="hljs-built_in">number</span>;\n<span class="hljs-title function_">initialize</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Ok</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) {\n  x = <span class="hljs-number">10</span>;\n}\n</code></pre>\n<p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p>\n<h2 id="四、类型守卫">四、类型守卫</h2>\n<p><strong>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</strong> </p>\n<p>目前主要有四种的方式来实现类型保护:</p>\n<h3 id="41-in-关键字">4.1 in 关键字</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Admin</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">privileges</span>: <span class="hljs-built_in">string</span>[];\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Employee</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">startDate</span>: <span class="hljs-title class_">Date</span>;\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnknownEmployee</span> = <span class="hljs-title class_">Employee</span> | <span class="hljs-title class_">Admin</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">printEmployeeInformation</span>(<span class="hljs-params">emp: UnknownEmployee</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Name: &quot;</span> + emp.<span class="hljs-property">name</span>);\n  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;privileges&quot;</span> <span class="hljs-keyword">in</span> emp) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Privileges: &quot;</span> + emp.<span class="hljs-property">privileges</span>);\n  }\n  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;startDate&quot;</span> <span class="hljs-keyword">in</span> emp) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Start Date: &quot;</span> + emp.<span class="hljs-property">startDate</span>);\n  } \n}\n</code></pre>\n<h3 id="42-typeof-关键字">4.2 typeof 关键字</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">&quot;number&quot;</span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>(padding + <span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>) + value;\n  }\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">&quot;string&quot;</span>) {\n      <span class="hljs-keyword">return</span> padding + value;\n  }\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected string or number, got &#x27;</span> + padding + <span class="hljs-string">&#x27;.&#x27;</span>);\n}\n</code></pre>\n<h3 id="43-instanceof-关键字">4.3 instanceof 关键字</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Padder</span> {\n  <span class="hljs-title function_">getPaddingString</span>(): <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpaceRepeatingPadder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Padder</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> numSpaces: <span class="hljs-built_in">number</span></span>) {}\n  <span class="hljs-title function_">getPaddingString</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">numSpaces</span> + <span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringPadder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Padder</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> value: <span class="hljs-built_in">string</span></span>) {}\n  <span class="hljs-title function_">getPaddingString</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;\n  }\n}\n<span class="hljs-keyword">let</span> <span class="hljs-attr">padder</span>: <span class="hljs-title class_">Padder</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpaceRepeatingPadder</span>(<span class="hljs-number">6</span>);\n<span class="hljs-keyword">if</span> (padder <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SpaceRepeatingPadder</span>) { <span class="hljs-comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span>\n}\n</code></pre>\n<h2 id="五、联合类型和类型别名">五、联合类型和类型别名</h2>\n<h3 id="51-联合类型">5.1 联合类型</h3>\n<p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params">name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt; {\n  <span class="hljs-comment">/* ... */</span>\n};\n</code></pre>\n<p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p>\n<pre><code class="language-ts"><span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&quot;semlinker&quot;</span>);\n<span class="hljs-title function_">sayHello</span>(<span class="hljs-literal">undefined</span>);\n</code></pre>\n<h3 id="52-类型别名">5.2 类型别名</h3>\n<p>类型别名用来给一个类型起个新名字。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[];\n<span class="hljs-keyword">let</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">message: Message</span>) =&gt; {\n  <span class="hljs-comment">// ...</span>\n};\n</code></pre>\n<h2 id="六、交叉类型">六、交叉类型</h2>\n<p>在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 &amp; 运算符可以将现有的多种类型叠加到 一起成为一种类型，它包含了所需的所有类型的特性。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">let</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = {\n  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> \n}\n</code></pre>\n<h2 id="七、typescript-函数">七、TypeScript 函数</h2>\n<h3 id="71-函数类型">7.1 函数类型</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-title class_">IdGenerator</span>: <span class="hljs-function">(<span class="hljs-params">chars: <span class="hljs-built_in">string</span>, nums: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserId</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, id: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> name + id;\n}\n<span class="hljs-title class_">IdGenerator</span> = createUserId;\n</code></pre>\n<h3 id="72-可选参数及默认参数">7.2 可选参数及默认参数</h3>\n<pre><code class="language-ts"><span class="hljs-comment">// 可选参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserId</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, id: <span class="hljs-built_in">number</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> name + id;\n}\n<span class="hljs-comment">// 默认参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserId</span>(<span class="hljs-params">name = <span class="hljs-string">&quot;semlinker&quot;</span>, id: <span class="hljs-built_in">number</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> name + id;\n}\n</code></pre>\n<p>在声明函数时，可以通过 ? 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要 注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p>\n<h2 id="八、typescript-接口">八、TypeScript 接口</h2>\n<p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对 「对象的形状(Shape)」进行描述。</p>\n<h3 id="81-对象的形状">8.1 对象的形状</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">let</span> <span class="hljs-attr">semlinker</span>: <span class="hljs-title class_">Person</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;semlinker&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">33</span>,\n};\n</code></pre>\n<h3 id="82-可选--只读属性">8.2 可选 | 只读属性</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  age?: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n<h3 id="83-任意属性">8.3 任意属性</h3>\n<p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <code>索引签名</code> 的形式来满足上述要求。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  age?: <span class="hljs-built_in">number</span>;\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;\n}\n<span class="hljs-keyword">const</span> p1 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;semlinker&quot;</span> };\n<span class="hljs-keyword">const</span> p2 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lolo&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span> };\n<span class="hljs-keyword">const</span> p3 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kakuqo&quot;</span>, <span class="hljs-attr">sex</span>: <span class="hljs-number">1</span> }\n</code></pre>\n<h3 id="84-接口与类型别名的区别">8.4 接口与类型别名的区别</h3>\n<p><strong>1.Objects/Functions</strong></p>\n<p>接口和类型别名都可以用来描述对象的形状或函数签名:</p>\n<p><strong>接口</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetPoint</span> {\n  (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n<p><strong>类型别名</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n};\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">SetPoint</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n</code></pre>\n<p><strong>2.Other Types</strong></p>\n<p>与接口类型不一样，类型别名可以用于一些其他类型，比如原始类型、联合类型和元组:</p>\n<pre><code class="language-ts"><span class="hljs-comment">// primitive</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-built_in">string</span>;\n<span class="hljs-comment">// object</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointY</span> = { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-comment">// union</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = <span class="hljs-title class_">PartialPointX</span> | <span class="hljs-title class_">PartialPointY</span>;\n<span class="hljs-comment">// tuple</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Data</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];\n</code></pre>\n<p><strong>3.Extend</strong></p>\n<p>接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类\n型别名，而反过来是不行的。</p>\n<p><strong>Interface extends interface</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PartialPointX</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PartialPointX</span> {\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; \n}\n</code></pre>\n<p><strong>Type alias extends type alias</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n</code></pre>\n<p><strong>Interface extends type alias</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PartialPointX</span> { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; }\n</code></pre>\n<p><strong>Type alias extends interface</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PartialPointX</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n</code></pre>\n<p><strong>4.Implements</strong></p>\n<p>类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n \n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Point</span> {\n  x = <span class="hljs-number">1</span>;\n  y = <span class="hljs-number">2</span>; \n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point2</span> = {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n};\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePoint2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Point2</span> {\n  x = <span class="hljs-number">1</span>;\n  y = <span class="hljs-number">2</span>; \n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; } | { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; };\n<span class="hljs-comment">// A class can only implement an object type or</span>\n<span class="hljs-comment">// intersection of object types with statically known members.</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PartialPoint</span> { <span class="hljs-comment">// Error</span>\n  x = <span class="hljs-number">1</span>;\n  y = <span class="hljs-number">2</span>; \n}\n</code></pre>\n<p><strong>5.Declaration merging</strong></p>\n<p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> { <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; }\n<span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };\n</code></pre>\n<h2 id="九、typescript-类">九、TypeScript 类</h2>\n<h3 id="91-类的属性与方法">9.1 类的属性与方法</h3>\n<p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> {\n  <span class="hljs-comment">// 静态属性</span>\n  <span class="hljs-keyword">static</span> <span class="hljs-attr">cname</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Greeter&quot;</span>; \n  <span class="hljs-comment">// 成员属性</span>\n  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;\n \n  <span class="hljs-comment">// 构造函数 - 执行初始化操作 </span>\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;\n  }\n  <span class="hljs-comment">// 静态方法</span>\n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class name is Greeter&quot;</span>;\n  }\n  <span class="hljs-comment">// 成员方法 </span>\n  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;\n  }\n}\n<span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>(<span class="hljs-string">&quot;world&quot;</span>);\n</code></pre>\n<p>那么成员属性与静态属性，成员方法与静态方法有什么区别:</p>\n<pre><code class="language-js"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Greeter</span> = <span class="hljs-comment">/** <span class="hljs-doctag">@class</span> */</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 构造函数 - 执行初始化操作 </span>\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Greeter</span>(<span class="hljs-params">message</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;\n  }\n  <span class="hljs-comment">// 静态方法</span>\n  <span class="hljs-title class_">Greeter</span>.<span class="hljs-property">getClassName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class name is Greeter&quot;</span>;\n  };\n  <span class="hljs-comment">// 成员方法</span>\n  <span class="hljs-title class_">Greeter</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;\n  };\n  <span class="hljs-comment">// 静态属性</span>\n  <span class="hljs-title class_">Greeter</span>.<span class="hljs-property">cname</span> = <span class="hljs-string">&quot;Greeter&quot;</span>; \n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Greeter</span>;\n}());\n<span class="hljs-keyword">var</span> greeter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>(<span class="hljs-string">&quot;world&quot;</span>);\n</code></pre>\n<h3 id="92-成员修饰符">9.2 成员修饰符</h3>\n<p>Typescript中成员修饰符包含 <code>public</code> 、<code>private</code> 、<code>protected</code></p>\n<p><code>public</code> 定义类的变量默认就是公共的，继承的子类可以通过this来访问</p>\n<p><code>private</code> 定义类的私有属性，只能在内部访问</p>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span>\n  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>\n  }\n\n  <span class="hljs-title function_">setName</span>(<span class="hljs-params">newName</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = newName\n  }\n}\n<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">getName</span>())\np.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;xbj&#x27;</span>)\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>) <span class="hljs-comment">// Property &#x27;name&#x27; is private and only accessible within class &#x27;Person&#x27;.</span>\n</code></pre>\n<p><code>protected</code> 在类的内部和子类中可以访问,在外面就访问不到了</p>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>){\n    <span class="hljs-variable language_">super</span>(name)\n  }\n  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>\n  }\n}\n</code></pre>\n<h3 id="93-访问器">9.3 访问器</h3>\n<p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_fullName</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>(): <span class="hljs-built_in">string</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fullName</span>;\n  }\n  <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fullName</span> = newName;\n  } \n}\n<span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();\nemployee.<span class="hljs-property">fullName</span> = <span class="hljs-string">&quot;Semlinker&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(employee.<span class="hljs-property">fullName</span>);\n</code></pre>\n<h3 id="94-类的继承">9.4 类的继承</h3>\n<p>继承(Inheritance)是一种联结类与类的层次模型。指的是一个类(称为子类、子接口)继承另外的一个类(称为父类、父接口)的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常⻅的关系。\n继承是一种 is-a 关系:</p>\n<img width="472" alt="image" style="margin: 20px auto;display: block;" src="https://user-images.githubusercontent.com/40552704/178437878-784762f9-cf07-484c-be28-140964a20bd8.png">\n\n<p>在 TypeScript 中，我们可以通过 <code>extends</code> 关键字来实现继承:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;\n  }\n  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; moved &#x27;</span> + distanceInMeters + <span class="hljs-string">&#x27;m.&#x27;</span>);\n  } \n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类的构造函数 </span>\n  }\n  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Slithering...&quot;</span>);\n    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);\n  } \n}\n<span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snake</span>(<span class="hljs-string">&quot;Sammy the Python&quot;</span>);\nsam.<span class="hljs-title function_">move</span>();\n</code></pre>\n<h3 id="95-抽象类">9.5 抽象类</h3>\n<p>使用 <code>abstract</code> 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多\n个抽象方法。所谓的抽象方法，是指不包含具体实现的方法:</p>\n<pre><code class="language-ts"> \n<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {}\n  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">say</span>(<span class="hljs-attr">words</span>: <span class="hljs-built_in">string</span>) :<span class="hljs-built_in">void</span>;\n}\n<span class="hljs-comment">// Cannot create an instance of an abstract class.(2511)</span>\n<span class="hljs-keyword">const</span> lolo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// Error</span>\n</code></pre>\n<p>抽象类不能被直接实例化，我们只能实现所有抽象方法的子类。具体如下所示:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>){}\n  <span class="hljs-comment">// 抽象方法</span>\n  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">say</span>(<span class="hljs-attr">words</span>: <span class="hljs-built_in">string</span>) :<span class="hljs-built_in">void</span>;\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Developer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">super</span>(name);\n  }\n  <span class="hljs-title function_">say</span>(<span class="hljs-attr">words</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;says&#x27;</span> + words);\n  } \n}\n<span class="hljs-keyword">const</span> lolo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Developer</span>(<span class="hljs-string">&quot;lolo&quot;</span>);\nlolo.<span class="hljs-title function_">say</span>(<span class="hljs-string">&quot;I love ts!&quot;</span>); <span class="hljs-comment">// lolo says I love ts!</span>\n</code></pre>\n<h2 id="十、typescript-泛型">十、TypeScript 泛型</h2>\n<p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是:类的实例成员、类的方法、函\n数参数和函数返回值。\n泛型(Generics)是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>\n<h3 id="101-泛型语法">10.1 泛型语法</h3>\n<p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。其实它没有什么特别，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p>\n<img width="753" alt="image" style="margin: 20px auto;display: block;" src="https://user-images.githubusercontent.com/40552704/178439009-0c859198-15b0-47b0-8a26-eb99a2e98647.png">\n\n<p>参考上面的图片，当我们调用 <code>identity&lt;Number&gt;(1)</code> ， <code>Number</code> 类型就像参数 <code>1</code> 一样，它将在出现 <code>T</code> 的任何位置填充该类型。图中 <code>&lt;T&gt;</code> 内部的 <code>T</code> 被称为类型变量，它是我们希望传递给 <code>identity</code> 函数的\n类型占位符，同时它被分配给 <code>value</code> 参数用来代替它的类型:此时 <code>T</code> 充当的是类型，而不是特定的 <code>Number</code> 类型。</p>\n<p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个 新的类型变量 <code>U</code> ，用于扩展我们定义的 identity 函数:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> identity &lt;T, U&gt;(<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U) : T {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n  <span class="hljs-keyword">return</span> value;\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(identity&lt;<span class="hljs-title class_">Number</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">68</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>));\n</code></pre>\n<img width="718" alt="image" style="margin: 20px auto;display: block;" src="https://user-images.githubusercontent.com/40552704/178439571-06724612-2635-429a-8fbd-c40e70fbd93f.png">\n\n<p>除了为类型变量显式设定值之外，一种更常⻅的做法是使编译器自动选择这些类型，从而使代码更简\n洁。我们可以完全省略尖括号，比如:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> identity &lt;T, U&gt;(<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U) : T {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n  <span class="hljs-keyword">return</span> value;\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">identity</span>(<span class="hljs-number">68</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>));\n</code></pre>\n<p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 <code>T</code> 和 <code>U</code>，而不需要显式指定它们。</p>\n<h3 id="102-泛型接口">10.2 泛型接口</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericIdentityFn</span>&lt;T&gt; {\n  (<span class="hljs-attr">arg</span>: T): T;\n}\n</code></pre>\n<h3 id="103-泛型类">10.3 泛型类</h3>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericNumber</span>&lt;T&gt; {\n  <span class="hljs-attr">zeroValue</span>: T;\n  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;\n}\n<span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">number</span>&gt;();\nmyGenericNumber.<span class="hljs-property">zeroValue</span> = <span class="hljs-number">0</span>;\nmyGenericNumber.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) {\n  <span class="hljs-keyword">return</span> x + y;\n};\n</code></pre>\n<h3 id="104-泛型工具类型">10.4 泛型工具类型</h3>\n<p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 <code>Partial</code>、<code>Required</code>、<code>Readonly</code>、<code>Record</code> 和 <code>ReturnType</code> 等。这里只简单介绍 <code>Partial</code> 工具类型。这里先介绍一些相关的基础知识，方便学习其它的工具类型。</p>\n<p><strong>1.typeof</strong></p>\n<p>在 TypeScript 中， <code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">const</span> <span class="hljs-attr">sem</span>: <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;semlinker&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">33</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Sem</span> = <span class="hljs-keyword">typeof</span> sem; <span class="hljs-comment">// -&gt; Person</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">toArray</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; {\n  <span class="hljs-keyword">return</span> [x];\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-keyword">typeof</span> toArray; <span class="hljs-comment">// -&gt; (x: number) =&gt; number[]</span>\n</code></pre>\n<p><strong>2.keyof</strong></p>\n<p><code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K1</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot;</span>\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K2</span> = keyof <span class="hljs-title class_">Person</span>[]; <span class="hljs-comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot;</span>\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K3</span> = keyof { [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Person</span> };  <span class="hljs-comment">// string | number</span>\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K4</span> = keyof <span class="hljs-built_in">any</span>;  <span class="hljs-comment">// string | number | symbol</span>\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K5</span> = keyof <span class="hljs-built_in">unknown</span>;  <span class="hljs-comment">// never</span>\n</code></pre>\n<p>在 TypeScript 中支持两种索引签名，数字索引和字符串索引:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringArray</span> {\n  <span class="hljs-comment">// 字符串索引</span>\n  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringArray1</span> {\n  <span class="hljs-comment">// 数字索引</span>\n  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K6</span> = keyof <span class="hljs-title class_">StringArray</span>; <span class="hljs-comment">// string | number </span>\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K7</span> = keyof <span class="hljs-title class_">StringArray1</span>; <span class="hljs-comment">// number </span>\n</code></pre>\n<p><strong>3.in</strong></p>\n<p><code>in</code> 用来遍历枚举类型:</p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Keys</span> = <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Obj</span> = {\n  [p <span class="hljs-keyword">in</span> <span class="hljs-title class_">Keys</span>]: <span class="hljs-built_in">any</span>\n} <span class="hljs-comment">// -&gt; { a: any, b: any, c: any }</span>\n</code></pre>\n<p><strong>4.infer</strong></p>\n<p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (\n  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]\n) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;\n</code></pre>\n<p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p>\n<p><strong>5.extends</strong></p>\n<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 <code>extends</code> 关键字添加泛型约束。</p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> {\n  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;\n}\n<span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);\n  <span class="hljs-keyword">return</span> arg;\n}\n</code></pre>\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型:</p>\n<pre><code class="language-ts"><span class="hljs-title function_">loggingIdentity</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// Error, number doesn&#x27;t have a .length property </span>\n</code></pre>\n<p>这时我们需要传入符合约束类型的值，必须包含必须的属性:</p>\n<pre><code class="language-ts"><span class="hljs-title function_">loggingIdentity</span>({<span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>});\n</code></pre>\n<p><strong>6.Partial</strong></p>\n<p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code> 。 </p>\n<p><strong>定义:</strong></p>\n<pre><code class="language-ts"><span class="hljs-comment">/**\n * node_modules/typescript/lib/lib.es5.d.ts\n * Make all properties in T optional\n */</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];\n};\n</code></pre>\n<p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code> ，最 后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p>\n<p><strong>示例:</strong></p>\n<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> {\n  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;\n}\n \n<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTodo</span>(<span class="hljs-params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) {\n  <span class="hljs-keyword">return</span> { ...todo, ...fieldsToUpdate };\n}\n<span class="hljs-keyword">const</span> todo1 = {\n  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Learn TS&quot;</span>,\n  <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;Learn TypeScript&quot;</span>,\n};\n<span class="hljs-keyword">const</span> todo2 = <span class="hljs-title function_">updateTodo</span>(todo1, {\n  <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;Learn TypeScript Enum&quot;</span>,\n});\n</code></pre>\n<p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code> ，即:</p>\n<pre><code class="language-ts">{\n   title?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;\n   description?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;\n}\n</code></pre>\n<h2 id="十一、typescript-装饰器">十一、TypeScript 装饰器</h2>\n<h2 id="十二、typescript-40-新特性">十二、TypeScript 4.0 新特性</h2>\n<h2 id="十三、编译上下文">十三、编译上下文</h2>\n'}},n={};function l(s){var p=n[s];if(void 0!==p)return p.exports;var e=n[s]={exports:{}};return a[s](e,e.exports,l),e.exports}l.m=a,s=[],l.O=function(a,n,p,e){if(!n){var t=1/0;for(i=0;i<s.length;i++){n=s[i][0],p=s[i][1],e=s[i][2];for(var c=!0,r=0;r<n.length;r++)(!1&e||t>=e)&&Object.keys(l.O).every((function(s){return l.O[s](n[r])}))?n.splice(r--,1):(c=!1,e<t&&(t=e));if(c){s.splice(i--,1);var o=p();void 0!==o&&(a=o)}}return a}e=e||0;for(var i=s.length;i>0&&s[i-1][2]>e;i--)s[i]=s[i-1];s[i]=[n,p,e]},l.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(s){if("object"==typeof window)return window}}(),l.o=function(s,a){return Object.prototype.hasOwnProperty.call(s,a)},function(){var s={831:0};l.O.j=function(a){return 0===s[a]};var a=function(a,n){var p,e,t=n[0],c=n[1],r=n[2],o=0;if(t.some((function(a){return 0!==s[a]}))){for(p in c)l.o(c,p)&&(l.m[p]=c[p]);if(r)var i=r(l)}for(a&&a(n);o<t.length;o++)e=t[o],l.o(s,e)&&s[e]&&s[e][0](),s[e]=0;return l.O(i)},n=self.webpackChunkmd_edit=self.webpackChunkmd_edit||[];n.forEach(a.bind(null,0)),n.push=a.bind(null,n.push.bind(n))}();var p=l.O(void 0,[60,477,256,456],(function(){return l(357)}));p=l.O(p)}();