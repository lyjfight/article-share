!function(){"use strict";var s,e={8456:function(s,e,a){a(1539),a(4747),a(1038),a(8783),a(7042);setTimeout((function(){var s=document.getElementsByClassName("markdown-body")[0],e=[],a={H1:!0,H2:!0,H3:!0,H4:!0,H5:!0,H6:!0};Array.from(s.children).forEach((function(s){a[s.tagName]&&e.push({tag:s.tagName,text:s.innerText,id:s.id,level:s.tagName.slice(1)})}));var n=document.createElement("div");n.className="directoryContent",e.forEach((function(s){var e=document.createElement("a");e.className="directoryItem",e.href="#"+s.id,e.innerText=s.text,e.style.paddingLeft=12*s.level+"px",n.appendChild(e)})),n.onclick=function(s){var e=s||window.event;Array.from(n.children).forEach((function(s){s.classList.remove("checked")})),e.target.classList.add("checked")},document.body.appendChild(n);var l=document.createElement("div");l.innerHTML="+",l.className="fullScreen",l.onclick=function(){window.fullScreen?(window.fullScreen=!1,l.innerHTML="+",document.exitFullScreen&&document.exitFullscreen(),console.log(document.mozExitFullScreen),document.mozCancelFullScreen&&document.mozCancelFullScreen(),document.webkitExitFullscreen&&document.webkitExitFullscreen(),document.msExitFullscreen&&document.msExitFullscreen()):(window.fullScreen=!0,l.innerHTML="-",document.documentElement.RequestFullScreen&&document.documentElement.RequestFullScreen(),console.log(document.documentElement.mozRequestFullScreen),document.documentElement.mozRequestFullScreen&&document.documentElement.mozRequestFullScreen(),document.documentElement.webkitRequestFullScreen&&document.documentElement.webkitRequestFullScreen(),document.documentElement.msRequestFullscreen&&document.documentElement.msRequestFullscreen())},document.body.appendChild(l)}),0);var n=document.createElement("div");n.className="markdown-body",n.innerHTML='<h1 id="babel的介绍">babel的介绍</h1>\n<p>Babel 是一个转译器，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>\n<h2 id="babel-的用途">babel 的用途</h2>\n<p>平时主要用 babel 来做一下几方面：</p>\n<ul>\n<li>语法转换，这个是最常用的功能，可以把代码中的 esnext 的新的语法、typescript 的语法转成基于目标环境支持的语法</li>\n<li>通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 <a href="https://github.com/zloirock/core-js">core-js</a>）</li>\n<li>源码转换（codemods），比如小程序转译工具 taro 的编译</li>\n</ul>\n<p>babel7 支持了 <code>preset-env</code>，可以指定 targets 来进行按需转换</p>\n<h2 id="babel-的编译流程">babel 的编译流程</h2>\n<p>babel 是 源码 到 源码 的转换，整体编译流程分为三步：</p>\n<ul>\n<li><code>parse</code>：通过 parser 把源码转成抽象语法树（AST）</li>\n<li><code>transform</code>：遍历 AST，调用各种 transform 插件对 AST 进行增删改</li>\n<li><code>generate</code>：把转换后的 AST 打印成目标代码，并生成 sourcemap</li>\n</ul>\n<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd652d544fb4cc29dd8882c82b8fad6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<h3 id="parse">parse</h3>\n<p>parse 阶段的目的是把源码字符串转换成机器能够理解的 AST，这个过程分为词法分析、语法分析。</p>\n<p>比如 <code>let name = &#39;li&#39;;</code> 这样一段源码，我们要先把它分成一个个不能细分的单词（token），也就是 <code>let</code>, <code>name</code>, <code>=</code>, <code>&#39;li&#39;</code>，这个过程是词法分析，按照单词的构成规则来拆分字符串成单词。</p>\n<p>之后要把 token 进行递归的组装，生成 AST，这个过程是语法分析，按照不同的语法结构，来把一组单词组合成对象，比如声明语句、赋值表达式等都有对应的 AST 节点。</p>\n<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a7a851ddc44109955a2e889ec353c0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<p><a href="https://astexplorer.net/#/gist/3af72fdd39c4950fd8afbcd488a18f7f/1b1b86d2c89d01c2570b903d3cb157faf6e124db">AST可视化网站</a></p>\n<h3 id="transform">transform</h3>\n<p>transform 阶段是对 parse 生成的 AST 的处理，会进行 AST 的遍历，遍历的过程中处理到不同的 AST 节点对 AST 节点进行增删改，返回新的 AST。</p>\n<h3 id="generate">generate</h3>\n<p>generate 阶段会把 AST 打印成目标代码字符串，并且会生成 sourcemap。不同的 AST 对应的不同结构的字符串。比如 <code>IfStatement</code> 就可以打印成 <code>if(test) {}</code> 格式的代码。这样从 AST 根节点进行递归的字符串拼接，就可以生成目标代码的字符串。</p>\n<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/251b958e353d437792d1b661261a962d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<p>sourcemap 记录了源码到目标代码的转换关系，通过它我们可以找到目标代码中每一个节点对应的源码位置，用于调试的时候把编译后的代码映射回源码，或者线上报错的时候把报错位置映射到源码。</p>\n<p>babel 的整个编译流程都是围绕 AST 来的，对于AST可以做一下事情</p>\n<ul>\n<li>linter 工具就是分析 AST 的结构，对代码规范进行检查。</li>\n<li>api 文档自动生成工具，可以提取源码中的注释，然后生成文档。</li>\n<li>type checker 会根据从 AST 中提取的或者推导的类型信息，对 AST 进行类型是否一致的检查，从而减少运行时因类型导致的错误。</li>\n<li>压缩混淆工具，这个也是分析代码结构，进行删除死代码、变量名混淆、常量折叠等各种编译优化，生成体积更小、性能更优的代码。</li>\n</ul>\n<h2 id="ast-节点">AST 节点</h2>\n<p>AST 是对源码的抽象，字面量、标识符、表达式、语句、模块语法、class 语法都有各自的 AST。</p>\n<h3 id="literal">Literal</h3>\n<p>Literal 是字面量的意思，比如 <code>let name = &#39;li&#39;</code>中，<code>&#39;li&#39;</code>就是一个字符串字面量 StringLiteral，相应的还有数字字面量 NumericLiteral，布尔字面量 BooleanLiteral，字符串字面量 StringLiteral，正则表达式字面量 RegExpLiteral 等。</p>\n<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aea1cbf9d9f4019b0b7744765f1e80b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<p>除上面这些这几种类型外，还有很多字面量。babel 就是通过 <code>xxxLiteral</code> 来抽象这部分内容的。</p>\n<h3 id="identifier">Identifier</h3>\n<p>Identifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是Identifer。</p>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;li&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);\n}\n\n<span class="hljs-keyword">const</span> obj = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;li&#x27;</span>\n}\n</code></pre>\n<p>比如上面这段代码中包含的 Identifer 有如下</p>\n<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2740953e8744df0848e7df2cdcdf451~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<h3 id="statement">Statement</h3>\n<p>statement 是语句，它是可以独立执行的单位，比如 break、continue、debugger、return 或者 if 语句、while 语句、for 语句，还有声明语句，表达式语句等。我们写的每一条可以独立执行的代码都是语句。</p>\n<p>语句末尾一般会加一个分号分隔，或者用换行分隔。</p>\n<p>下面这些我们经常写的代码，每一行都是一个 Statement：</p>\n<pre><code class="language-js"><span class="hljs-keyword">break</span>;    <span class="hljs-title class_">BreakStatement</span>\n<span class="hljs-keyword">continue</span>;    <span class="hljs-title class_">ContinueStatement</span>\n<span class="hljs-keyword">return</span>;    <span class="hljs-title class_">ReturnStatement</span>\n<span class="hljs-keyword">debugger</span>;    <span class="hljs-title class_">DebuggerStatement</span>\n<span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>();    <span class="hljs-title class_">ThrowStatement</span>\n{}    <span class="hljs-title class_">BlockStatement</span>\n<span class="hljs-keyword">try</span> {} <span class="hljs-keyword">catch</span>(e) {} <span class="hljs-keyword">finally</span>{}    <span class="hljs-title class_">TryStatement</span>\n<span class="hljs-keyword">if</span> (v) {}    <span class="hljs-title class_">IfStatement</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {}    <span class="hljs-title class_">ForInStatement</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i ++) {}    <span class="hljs-title class_">ForStatement</span>\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}    <span class="hljs-title class_">WhileStatement</span>\n<span class="hljs-keyword">do</span> {} <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)    <span class="hljs-title class_">DoWhileStatement</span>\n<span class="hljs-keyword">switch</span> (v){<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;<span class="hljs-attr">default</span>:;}    <span class="hljs-title class_">SwitchStatement</span>\n<span class="hljs-keyword">with</span> (a){}    <span class="hljs-title class_">WithStatement</span>\n</code></pre>\n<p>语句是代码执行的最小单位，可以说，代码是由语句（Statement）构成的。babel 就是通过 <code>xxxStatement</code> 来抽象这部分内容的。</p>\n<h3 id="declaration">Declaration</h3>\n<p>声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个变量、函数、class、import、export 等。</p>\n<p>比如下面这些语句都是声明语句：</p>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;    <span class="hljs-title class_">VaiableDeclaration</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>){}    <span class="hljs-title class_">FunctionDeclaration</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}    <span class="hljs-title class_">ClassDeclaration</span>\n<span class="hljs-keyword">import</span> d <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;e&#x27;</span>;    <span class="hljs-title class_">ImportDeclaration</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> e = <span class="hljs-number">1</span>;    <span class="hljs-title class_">ExportDefaultDeclaration</span>\n<span class="hljs-keyword">export</span> {e};    <span class="hljs-title class_">ExportNamedDeclaration</span>\n<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;e&#x27;</span>;    <span class="hljs-title class_">ExportAllDeclaration</span>\n</code></pre>\n<p>声明语句用于定义变量，这也是代码中一个基础组成部分。</p>\n<h3 id="expression">Expression</h3>\n<p>expression 是表达式，特点是执行完以后有返回值，这是和语句 (statement) 的区别。</p>\n<p>下面是一些常见的表达式</p>\n<pre><code class="language-js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]    <span class="hljs-title class_">ArrayExpression</span> <span class="hljs-comment">//数组表达式</span>\na = <span class="hljs-number">1</span>    <span class="hljs-title class_">AssignmentExpression</span> <span class="hljs-comment">//赋值表达式</span>\n<span class="hljs-number">1</span> + <span class="hljs-number">2</span>;    <span class="hljs-title class_">BinaryExpression</span> <span class="hljs-comment">//二元表达式</span>\n-<span class="hljs-number">1</span>;    <span class="hljs-title class_">UnaryExpression</span> <span class="hljs-comment">//一元表达式</span>\n<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){};    <span class="hljs-title class_">FunctionExpression</span> <span class="hljs-comment">//函数表达式</span>\n() =&gt; {};    <span class="hljs-title class_">ArrowFunctionExpression</span> <span class="hljs-comment">//箭头函数表达式</span>\n<span class="hljs-keyword">class</span>{};    <span class="hljs-title class_">ClassExpression</span> <span class="hljs-comment">//class表达式</span>\n<span class="hljs-variable language_">this</span>;    <span class="hljs-title class_">ThisExpression</span> <span class="hljs-comment">//this表达式</span>\n</code></pre>\n<h3 id="class">Class</h3>\n<p>class 的语法也有专门的 AST 节点来表示。</p>\n<p>整个 class 的内容是 ClassBody，属性是 ClassProperty，方法是ClassMethod\n比如下面的代码</p>\n<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Guang</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>{\n    name = <span class="hljs-string">&#x27;li&#x27;</span>;\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}\n    <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) {}\n}\n</code></pre>\n<p>它的AST组成可见\n<a href="https://astexplorer.net/#/gist/3af72fdd39c4950fd8afbcd488a18f7f/d073d50570450a049a1c924627bf01f2a5469f36">AST可视化</a></p>\n<h3 id="modules">Modules</h3>\n<p>es module 是语法级别的模块规范，所以也有专门的 AST 节点。</p>\n<h4 id="import">import</h4>\n<p>import 有 3 种语法：</p>\n<p>named import：</p>\n<pre><code class="language-js"><span class="hljs-keyword">import</span> {c, d} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;c&#x27;</span>;\n</code></pre>\n<p>default import：</p>\n<pre><code class="language-js"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a&#x27;</span>;\n</code></pre>\n<p>namespaced import:</p>\n<pre><code class="language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;b&#x27;</span>;\n</code></pre>\n<p>这 3 种语法都对应 ImportDeclaration 节点，但是 specifiers 属性不同，分别对应 ImportSpicifier、ImportDefaultSpecifier、ImportNamespaceSpcifier。</p>\n<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df707f20460649ae99357ac987e00dae~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<p>图中黄框标出的就是 specifier 部分。可以直观的看出整体结构相同，只是 specifier 部分不同，所以 import 语法的 AST 的结构是 ImportDeclaration 包含着各种 import specifier。</p>\n<h4 id="export">export</h4>\n<p>export 也有3种语法：</p>\n<p>named export：</p>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> { b, d};\n</code></pre>\n<p>default export：</p>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;\n</code></pre>\n<p>all export：</p>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;c&#x27;</span>;\n</code></pre>\n<p>分别对应 ExportNamedDeclaration、ExportDefaultDeclaration、ExportAllDeclaration 的 AST。</p>\n<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcea64c46f674ab2909a826836c2ca14~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n<h3 id="program--directive">Program &amp; Directive</h3>\n<p>program 是代表整个程序的节点，它有 body 属性代表程序体，存放 statement 数组，就是具体执行的语句的集合。还有 directives 属性，存放 Directive 节点，比如<code>&quot;use strict&quot;</code> 这种指令会使用 Directive 节点表示。</p>\n<p>Program 是包裹具体执行语句的节点，而 Directive 则是代码中的指令部分。</p>\n<h3 id="file--comment">File &amp; Comment</h3>\n<p>babel 的 AST 最外层节点是 File，它有 program、comments、tokens 等属性，分别存放 Program 程序体、注释、token 等，是最外层节点。</p>\n<p>注释分为块注释和行内注释，对应 CommentBlock 和 CommentLine 节点。</p>\n<pre><code class="language-js"><span class="hljs-comment">/* lyj */</span>    \n<span class="hljs-title class_">CommentBlock</span>\n\n<span class="hljs-comment">// lyj       </span>\n<span class="hljs-title class_">CommentLine</span>\n</code></pre>\n<h2 id="babel-的-api">babel 的 api</h2>\n<p>babel 的编译流程分为三步：parse、transform、generate，每一步都暴露了一些 api 出来。</p>\n<ul>\n<li>parse 阶段有<code>@babel/parser</code>，功能是把源码转成 AST</li>\n<li>transform 阶段有 <code>@babel/traverse</code>，可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要 <code>@babel/types</code> 了，当需要批量创建 AST 的时候可以使用 <code>@babel/template</code> 来简化 AST 创建逻辑。</li>\n<li>generate 阶段会把 AST 打印为目标代码字符串，同时生成 sourcemap，需要 <code>@babel/generator</code> 包</li>\n<li>中途遇到错误想打印代码位置的时候，使用 <code>@babel/code-frame</code> 包</li>\n<li>babel 的整体功能通过 <code>@babel/core</code> 提供，基于上面的包完成 babel 整体的编译流程，并应用 plugin 和 preset。</li>\n</ul>\n<p>主要学习的就是 <code>@babel/parser</code>，<code>@babel/traverse</code>，<code>@babel/generator</code>，<code>@babel/types</code>，<code>@babel/template</code> 这五个包的 api 的使用。</p>\n<p>这些包的 api 都可以在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.babeljs.cn%2Fdocs%2Fbabel-parser" title="https://www.babeljs.cn/docs/babel-parser">文档</a>里查看：</p>\n<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15ac3f213c4c4c9baf7cf755294e56a3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n',document.body.appendChild(n)}},a={};function n(s){var l=a[s];if(void 0!==l)return l.exports;var p=a[s]={exports:{}};return e[s](p,p.exports,n),p.exports}n.m=e,s=[],n.O=function(e,a,l,p){if(!a){var t=1/0;for(i=0;i<s.length;i++){a=s[i][0],l=s[i][1],p=s[i][2];for(var c=!0,r=0;r<a.length;r++)(!1&p||t>=p)&&Object.keys(n.O).every((function(s){return n.O[s](a[r])}))?a.splice(r--,1):(c=!1,p<t&&(t=p));if(c){s.splice(i--,1);var o=l();void 0!==o&&(e=o)}}return e}p=p||0;for(var i=s.length;i>0&&s[i-1][2]>p;i--)s[i]=s[i-1];s[i]=[a,l,p]},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(s){if("object"==typeof window)return window}}(),n.o=function(s,e){return Object.prototype.hasOwnProperty.call(s,e)},function(){var s={37:0,136:0};n.O.j=function(e){return 0===s[e]};var e=function(e,a){var l,p,t=a[0],c=a[1],r=a[2],o=0;if(t.some((function(e){return 0!==s[e]}))){for(l in c)n.o(c,l)&&(n.m[l]=c[l]);if(r)var i=r(n)}for(e&&e(a);o<t.length;o++)p=t[o],n.o(s,p)&&s[p]&&s[p][0](),s[p]=0;return n.O(i)},a=self.webpackChunkmd_edit=self.webpackChunkmd_edit||[];a.forEach(e.bind(null,0)),a.push=e.bind(null,a.push.bind(a))}();var l=n.O(void 0,[60,477,256,136],(function(){return n(8456)}));l=n.O(l)}();